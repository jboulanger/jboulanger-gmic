#@gmic
#
#  File        : jboulanger.gmic
#                ( G'MIC commands file )
#
#  Description : Define a set of gmic commands (mostly useful for bioimage analysis)
#
#  Copyright   : Jerome Boulanger
#
#  License     : CeCILL v2.0
#                ( http://www.cecill.info/licences/Licence_CeCILL_V2-en.html )
#
#  This software is governed by the CeCILL  license under French law and
#  abiding by the rules of distribution of free software.  You can  use,
#  modify and/ or redistribute the software under the terms of the CeCILL
#  license as circulated by CEA, CNRS and INRIA at the following URL
#  "http://www.cecill.info".
#
#  As a counterpart to the access to the source code and  rights to copy,
#  modify and redistribute granted by the license, users are provided only
#  with a limited warranty  and the software's author,  the holder of the
#  economic rights,  and the successive licensors  have only  limited
#  liability.
#
#  In this respect, the user's attention is drawn to the risks associated
#  with loading,  using,  modifying and/or developing or reproducing the
#  software by the user in light of its specific status of free software,
#  that may mean  that it is complicated to manipulate,  and  that  also
#  therefore means  that it is reserved for developers  and  experienced
#  professionals having in-depth computer knowledge. Users are therefore
#  encouraged to load and test the software's suitability as regards their
#  requirements in conditions enabling the security of their systems and/or
#  data to be ensured and,  more generally, to use and operate it in the
#  same conditions as regards security.
#
#  The fact that you are presently reading this means that you have had
#  knowledge of the CeCILL license and that you accept its terms.
#


#---------------------------------
#
#@gmic :: Input/Output
#
#---------------------------------

#@gmic tiff3d
#@gmic : Input a 3D tif as a 3D image
#@gmic : Note: This is useful for loading several 3D image stack
tiff3d : -e[^-1] "Load the file $1 as a 3D image"
-v - n=@#
-i $1 -a[{$n}--1] z
-v +

#@gmic toff3d
#@gmic : Output a 3D tif as a 3D image
toff3d : -e[^-1] "Save the 3D image as a tiff file"
-v -
-repeat @#
-o[$>] @{"-filename \"$1\","$>}
-done
-v +

#---------------------------------
#
#@gmic :: 3D Rendering
#
#---------------------------------

#@gmic boundingbox3d : _separation
#@gmic : Bounding box of a 3D volume
#@gmic : $ 100,100,100 -boundingbox3d
boundingbox3d : -skip ${1=10}
-e[^-1] "3D Bounding box"
-repeat @# -l[$>]
-box3d @{0,w},@{0,h},@{0,d} -primitives3d[-1] 1  -opacity3d[-1] .25
-if {$1>0}
  -plane3d @{0,w},@{0,h},$1,{round(@{0,h}/@{0,w}*$1)} -primitives3d[-1] 1 -opacity3d[-1] .1
-endif
-rm[0]
-+3d
-endl -done

#@gmic rendervolume  : _size,_quality,_opacity
#@gmic : Pseudo volumic rendering
#@gmic : $ 100,100,100 -noise 1 -blur 10,0 -max 0 -resize 100%,100%,100%,3,0 -n 0,100 -f 'if(c==0,z*i(x,y,z,0),if(c==1,i(x,y,z,0)*(100-z),0))' -rendervolume
rendervolume: -skip ${1=8},${2=5},${3=.1}
-e[^-1] "Pseudo volumic rendering of image with size $1 quality $2 and opactiy $3"
-v - -repeat @# -l[$>]
-mirror x
-repeat $2
--l[0]
  --threshold2 {($>+1)/($2+1)*(iM-im)+im},{($>+2)/($2+1)*(iM-im)+im+1}
  -*[-2,-1]
  -pointcloud3d -gaussians3d $1,{$3*($<+1)/$2}
-endl -done -rm[0] -+3d -md3d -1  -+3d {.5},{.5},{.5}
-endl -done -v +

#@gmic displayvolume : _size,_quality,_opacity
#@gmic : Display the volume with black background, a bounding box and a volumic rendering of the data
#@gmic : $ 100,100,100 -noise 1 -blur 10,0 -max 0 -resize 100%,100%,100%,3,0 -n 0,100 -f 'if(c==0,z*i(x,y,z,0),if(c==1,i(x,y,z,0)*(100-z),0))' -displayvolume 8,5,.1
displayvolume: -skip ${1=8},${2=5},${3=.1}
-e[^-1] "display_volume with size $1 quality $2 and opactiy $3"
-v -
--boundingbox3d 20
-rendervolume[0] $1,$2,$3
-+3d
-background3d 0,0,0
-v +

#@gmic view3d : _angle1,_angle2
#@gmic : Apply a 3D view
#@gmic : $ 50,50,50,3 -noise 10 -blur 5 -max 0 -n 0,255 -displayvolume 32,5,1 -view3d
view3d : -skip ${1=25},${2=-120}
-e[^-1] "Apply 3D view"
-v - -repeat @# -l[$>]
-rotate3d 0,0,1,$1 -rotate3d 1,0,0,$2
-endl -done -v +

#@gmic colordepth
#@gmic : Color depth coding
#@gmic : $ 100,100,100 -noise 1 -blur 10,0 -max 0 -colordepth 5
colordepth: -skip ${1=5}
-e "colordepth coding with lut $1"
-v - -repeat @# -l[$>]
-_colordepth_volume $1 -s z -+
-endl -done -v +

#@gmic colordepth_volume
_colordepth_volume: -skip ${1=5}
-v - -repeat @# -l[$>]
# make a 3D volume of the same size, color it, resize orignal in color and multiply
-i [0] -f[-1] 'z/(d-1)*255' -map[-1] $1 -resize[0] 100%,100%,100%,3 -*
-endl -done -v +

colordepth_scale: -skip ${1=5}
10,@{0,h-10} -f[-1] '(h-y)/(h-1)*255' -map[-1] $1 -frame[-1] 5,5,0,0,0



#---------------------------------
#
#@gmic :: Feature detections
#
#---------------------------------

#@gmic detect_events : _scale_xy,_scale_t,_threshold
#@gmic : Detect space time events using space time interest points
#@gmic : $ 100,100,100 -noise 1 -blur 2 -detectevents
detectevents : -skip ${1=1},${2=1},${3=9}
-e[^-1] "detect events with scale_xy $1 scale_z $2 and threshold $3"
-v - -repeat @# -l[$>]
-blur_xy $1 -blur_z $2 -structuretensors -blur_xy $1 -blur_z $2
-s z -repeat @# -l[$>] -eigen -k[0] -s c -k[2] -endl -done -a z
thres={@{0,ia}+$3*sqrt(@{0,iv})}
--max_patch[0] 8 -threshold[0] $thres -*
-endl -done -v +

#@gmic detect_spots : _scale,_threshold
#@gmic : Detect spots in the image
#@gmic : $ 100,100 -noise .2,2 -blur 1 -n 0,255 -noise 5 --detect_spots , -pointscoordinates[-1] -resize[0] 100%,100%,1,3,1 -circles 5,.5,128,128,32 -k[0]
detect_spots : -skip ${1=1},${2=4}
-e[^-1] "detect events with scale $1 and threshold $2"
-v - -repeat @# -l[$>]
-blur $1 --blur $1 --
thres={$2*@{-mad[0]}}
--max_patch[0] 3 --threshold[0] $thres -*
-endl -done -v +

#@gmic pointscoordinates
#@gmic : Return the list of points in the image as 3*N columns vector
#@gmic : $ 100,100 -noise .1,2 --pointscoordinates
pointscoordinates :
-e[^-1] "return the list of points in the image"
-v - -repeat @# -l[$>]
-pointcloud3d -s3d -k[2] -split y,{h/3} -a x
-endl -done -v +

#@gmic circles : _size,_opacity,_color
#@gmic : plot circles on image [0] at coordinates given by image [1]
#@gmic : $ 256,256 -noise .1,2 --pointscoordinates --circles 5 -rm[-1]
#@gmic : $ image.jpg --l[0] -blur 3 -structuretensors -blur 3 -eigen -k[0] -channels 1 --gt {9*@{-mad}} --max_patch[0] 8 -* -pointscoordinates -endl -circles 5 -rm[-1]
circles : -skip ${1=10},${2=1},${3=255}
-e[^-1] "draw @{1,w} circles on image [0]"
-v -
-repeat {@{1,w}}
  -if {@{0,d}>1}
    x={@{1,i($>,0)}} y={@{1,i($>,1)}} z={@{1,i($>,2)}}
    -repeat @{0,s} -sh[0] $z,$z,$> -ellipse[-1] $x,$y,$1,$1,0,$2,0xFFFFFF,$3 -rm[-1] -done
   -else
    x=@{1,i($>,0)} y=@{1,i($>,1)}
    -ellipse[0] $x,$y,$1,$1,0,$2,0xFFFFFF,$3
  -endif
-done

#@gmic addtext : _size
#@gmic : Add labels on image [0] at coordinates given by image [1]
#@gmic : $ 256,256 -noise .1,2 --pointscoordinates -addtext 5 -rm[-1]
addtext : -skip ${1=21},${2=128}
-e[^-1] "add text labels from @{1,w} points"
-v -
-repeat {@{1,w}}
  -if {@{0,d}>1}
    x={@{1,i($>,0)}} y={@{1,i($>,1)}} z={@{1,i($>,2)}} id={$>+1}
    -repeat @{0,s} -sh[0] $z,$z,$> -text[-1] $id,$x,$y,21,.5,$2,$2,$2 -rm[-1] -done
  -else
    x=@{1,i($>,0)} y=@{1,i($>,1)} id={$>+1}
    -text[0] $id,$x,$y,21,.5,$2,$2,$2
  -endif
-done

#@gmic croparound : _size_xy,_size_z
#@gmic : Crop image [0] around coordinates given by image [1]
#@gmic : $ image.jpg 100%,100% -f[-1] 0 -noise[-1] .1,2 --pointscoordinates[-1] --croparound[0,-1] 5 -append_tiles[3--1] ,  -rm[-2] -dilate[1] 5 -*[1] 128 -blend[0,1] add
croparound :  -skip ${1=10},${2=10}
-e[^-1] "crop image [0] around "@{1,w}" coordinates given by image [1]"
-v -
-repeat {@{1,w}}
  -if {@{0,d}>1}
    x=@{1,i($>,0)} y=@{1,i($>,1)} z=@{1,i($>,2)}
    --crop[0] {$x-$1},{$y-$1},{$z-$2},{$x+$1},{$y+$1},{$z+$2}
  -else
    x=@{1,i($>,0)} y=@{1,i($>,1)}
    --crop[0] {$x-$1},{$y-$1},{$x+$1},{$y+$1}
  -endif
-done -rm[0,1] -v +

#@gmic random_walks : width,height,length,number,speed
#@gmic : Generate random walks tracks (list of coordinates x,y,t as a Nx3 image.)
#@gmic : $ 100,100,20  -random_walks 100,100,20,5,1 -circles 1 -k[0] -blur_xy 1 -s z -max
#@gmic : $ 100,100,20  -random_walks 100,100,20,10,1 -circles 1 -k[0] -blur 1 -n 0,255 -displayvolume 8,10,1 -rotate3d 0,0,1,25 -rotate3d 1,0,0,-120 -snapshot3d 600,1,0,0,0 -autocrop
random_walks :
number=$4 width=$1 height=$2 length=$3 speed=$5
$number,3
-l[-1]
  -noise 1,1
  -sh 0,0,0,0 -n[-1] 1,{$width-1} -rm[-1]
  -sh 1,1,0,0 -n[-1] 1,{$height-1} -rm[-1]
  -sh 2,2,0,0 -f[-1] 0 -rm[-1]
  -repeat {$length-1} --l[-1]
    -noise 1
    -sh 0,0,0,0 -c[-1] 1,{$width-2} -rm[-1]
    -sh 1,1,0,0 -c[-1] 1,{$height-2} -rm[-1]
    -sh 2,2,0,0 -f[-1] '$>+1' -rm[-1]
  -endl -done -a x
-endl

#---------------------------------
#
#@gmic :: Filtering and deconvolution
#
#---------------------------------

#@gmic movavg : _size>=1
#@gmic : moving average of image list with a box filter of size _size
#@gmic : $ 11 -f 'x>w/2' --l[-1] -s x -movavg 9 -a x -endl  --blur[0] 1.2 -a c -display_graph
movavg : -check "$1>=1"
-e[^-1] "moving average with size "$1 -v -
n={$1-1}
-repeat $n
  -repeat {{@#}-1} --+[{$>},{$>+1}] -*[-1] .5 -rm[$>] -mv[-1] $> -done
  -reverse
-done
-if {$n%2!=0} -reverse -endif
-v +

#@gmic fftshift
#@gmic : shift a image so that the fft has it center in the middle
#@gmic : $ image.jpg -fftshift
fftshift :
-v - -repeat @# -l[$>]
-shift {-int(w/2)},{-int(h/2)},{-int(d/2)},0,2
-endl -done -v +

#@gmic whiten_frequency : _alpha
#@gmic : Whitening filter (equalize the frequency of the image; nothing todo with color)
#@gmic : $ image.jpg -whiten_frequency
whiten_frequency : -check "${1=.25}>=0"
-e[^-1] "Whiten the frequency with parameter "$1
-v - -repeat @# -l[$>]
#E=@{0,sqrt(iv)}
-fft --a c -norm[-1] -pow[-1] $1 -max[-1] 1e-12 -/[-1] {ia} -/[0-1] [2] -rm[2] -ifft -k[0]
#-* {$E/sqrt(iv)}
-endl -done -v +

#@gmic localvariance : _radius
#@gmic : Local variance filter
#@gmic : $ image.jpg  -localvariance
localvariance: -skip ${1=2}
-e[^-1] "Local Variance filter with scale "$1
-v - -repeat @# -l[$>]
--blur $1,1,1 -- -sqr -blur $1,1,1
-endl -done -v +

#@gmic normalize_local_variance : _amplitude,_radius,_threshold,_repeat
#@gmic : Local variance normalization
#@gmic : $ image.jpg  -localvariance
normalize_local_variance: -skip ${1=50},${2=2},${3=25},${4=1}
  -e[^-1] "Normalize local variance with amplitude $1, scale $2, threshold $3 (x$4 times)."
  -v -
  -repeat $4
   --localvariance $2 -sqrt[-1] -max[-1] $3 # compute local standard deviation
   --blur[0] $2,1,1 ---[0,-1] -/[-1] [1] -*[-1] $1 -+[-2,-1] -k[-1] # x = <x> + alpha * (x-<x>)/<x'x>
  -done -v +

#@gmic localwiener : _radius
#@gmic : Local Wiener filtering
#@gmic : X = <X> + ((<X-<X>>)'(<X-<X>>) - <N'N>)/(<X-<X>>)'(<X-<X>>) (X-<X>)
#@gmic : $ image.jpg -noise 10 -localwiener
localwiener : -skip ${1=2}
-e[^-1] "Local Wiener filtering"
-v - -repeat @# -l[$>]
sigma=@{-noise_std}
--blur $1,1,1 # mean
--localvariance[0] $1 ---[-1] {$sigma*$sigma} -reverse[-1,-2] -/[-1,-2] # variance
---[0,1] # img-mean
-*[-1,-2] -+[-1,-2] -k[-1]
-endl -done -v +

#@gmic periodize
#@gmic : Periodization of the image
#@gmic : $ image.jpg -periodize
periodize :
-e[^-1] "periodize"
-v - -repeat @# -l[$>]
-if {w>1} --mirror x -a x -endif
-if {h>1} --mirror y -a y -endif
-if {d>1} --mirror z -a z -endif
-endl -done -v +

#@gmic tape
#@gmic : apply a Hann window
#@gmic : $ image.jpg -tape
tape :
-e[^-1] "apply a Hann tapering window"
-v - -repeat @# -l[$>]
   -if {w>1} -f 'i*sin(pi*x/(w-1))^2' -endif
   -if {h>1} -f 'i*sin(pi*y/(h-1))^2' -endif
   -if {d>1} -f 'i*sin(pi*z/(d-1))^2' -endif
-endl -done -v +

#@gmic powerspectrum :
#@gmic : Compute power spectrum
#@gmic : $ image.jpg -powerspectrum
powerspectrum :
-e[^-1] "Compute power spectrum"
-v - -repeat @# -l[$>]
-display_fft -k[0]
-endl -done -v +

#@gmic fouriermix : _cut_of_frequency
#@gmic :  Mix two images using their respectives low and high frequencies
#@gmic : $ image1.jpg image2.jpg -fouriermix .5
fouriermix : -skip ${1=50%}
-e[^-1] "fourier mix images."
-fft[0] -fft[2] -fftshift
# make a mask
100%,100% -circle[-1] 50%,50%,$1,1,1 -blur[-1] 10%,1,1 -n[-1] 0,1
-*[0,1] [-1] -negative[-1] -*[2,3] [-1] -rm[-1] -+[0,2] -+[1,2] -fftshift
-ifft  -k[0]

#@gmic fouriercut : _threshold
#@gmic : Illustrate the thresholding of Fourier coefficients
#@gmic : $ image.jpg -fouriercut
fouriercut : -skip ${1=1}
-e[^-1] "Threshold Fourier coefficients with threshold "$1"."
-v - -repeat @# -l[$>]
--tape -l[-1] -powerspectrum -blur 5  -threshold {ia+$1*sqrt(iv)} -fftshift -endl
-fft[0] -*[0] [-1] -*[1] [-1] -rm[-1] -ifft -k[0]
-endl -done -v +

#@gmic unstrip : _smoothness,_scale,_threshold
#@gmic : Remove stripes in an image
#@gmic : $ image.jpg -f '.5*i*(1+.25*sin(x))' --unstrip
unstrip : -skip ${1=25},${2=20},${3=4}
-e[^-1] "Remove stripes"
-v - -repeat @# -l[$>]
# create a mask
--tape -l[-1] -powerspectrum -norm -detect_spots 1,$3 -dilate_circ $2 -gt 0 -n 0,1
-negative -circle 50%,50%,$2,1,1 -blur $1 -n 0,1 -fftshift -if {iM==0} -f 1 -endif -endl
#apply the mask
-fft[0] -*[0] [-1] -*[1] [-1] -rm[-1] -ifft -k[0]
-endl -done -v +

#@gmic autocorrelate
#@gmic : Autocorrelation
#@gmic : $ image.jpg -autocorrelate
autocorrelate :
-e[^-1] "Compute autocorrelation"
-v - -repeat @# -l[$>]
-fft -sqr -+ -sqrt -ifft -k[0] -fftshift
-endl -done -v +

#@gmic psf : _NA,_n,_wavelength,_pixel_size
#@gmic : Generate a rough approximation of a microscope PSF
#@gmic : $ 64,64,32 -psf , -+ 1 -log
psf : -skip ${1=1.40},${2=1.33},${3=488},${4=160},${5=200}
C={2*pi/$3*$1/$2*50}
-v - -repeat @# -l[$>]
-f 'dx=x-w/2;dy=y-h/2;dz=z-d/2;if($C*sqrt(dx*dx+dy*dy)<(d-abs(dz)),1,0)'
-blur 1
-s z -repeat @# -l[$>] -fftpolar -k[0] -endl -done -a z
-sqr
-endl -done -v +

#@gmic beads2psf :
#@gmic : Compute an approximate PSF from an image bead using autocorrelation method
beads2psf : -skip ${1=5}
-e[^-1] "Compute a PSF from an image bead using autocorrelation method"
-v - -repeat @# -l[$>]
-tape 1  -autocorrelate -threshold {sqrt(@{0,iv})},1
-f 'dx=x-w/2;dy=y-h/2;dz=z-d/2;sigma=9+$1*dz*dz;i*exp(-.5*(dx*dx+dy*dy)/(sigma))/sqrt(2*pi*sigma)'
-sqr
-endl -done -v +

#@gmic simmod:
#@gmic : Analyse SIM modulation by dividing by the sum of the images
simmod :
--+ -*[-1] {1/(@#-1)} -/[0--2] [-1] -rm[-1]

#@gmic spotify : _scale>0,_nb_iter>0,
#@gmic : Make everything look like a spot
#@gmic : Default values '_nb_iter=1, _scale=1'
#@gmic : $ image.jpg --spotify 1,10
#@gmic : $ image.jpg --spotify 1,20 -norm[-1] -gt[-1] 5% -blur 1 -*
spotify : -check "${1=1}>0 && ${2=1}>0"
-e[^-1] "Spotify with scale $1 with $2 iterations"
-v - -repeat @# -l[$>]
s=@{0,a} -repeat $2 -blur $1 --blur {2*$1} -- -cut 0,100% -f 'i*{$s}/ia' -done
-endl -done -v +

#@gmic tubeness : _scale>0
#@gmic : Tubeness filter based on the eigen value of the Hessian
#@gmic : Default values '_scale=1'
#@gmic : $ image.jpg --tubeness 3
#@gmic : $ image.jpg --tubeness 1 -n 0,255 -blend add
tubeness : -check "${1=1}>0"
-e[^-1] "Tubeness with scale $1."
-v - -repeat @# -l[$>]
  -blur $1
  -s c -repeat @# -l[$>]
    -hessian -a c -eigen -k[0] -s c -k[1] -* -1 -cut 0,100%
  -endl -done -a c
-endl -done -v +

#@gmic schizo : _amplitude,_amplitude_normal,_nb_iterations,_strength
#@gmic : Schizo filter gives either a furry image or a smoothed image
#@gmic : Default values '_amplitude=100,amplitude_normal=-50 _nb_iter=5,_strength=.75'
#@gmic : $ image.jpg --schizo 100,-50 --schizo[0] -50,100 -max 0
schizo : -skip ${1=100},${2=-50},${3=5},${4=.75}
-e[^-1] "Schizo filter smoothing with // $1 and T $2 and $3 iterations."
-v - -repeat @# -l[$>]
[0]
-repeat $3
 -l[-1]
   --iee -*[-1] {$1/(0.0001+max(abs(@{-1,m}),abs(@{-1,M})))}
   --inn[0] -*[-1] {$2/(0.0001+max(abs(@{-1,m}),abs(@{-1,M})))}
   -+
 -endl
 -*[-1] $4  --*[0] {1-$4} -+[-1,-2]
-done -rm[0]
-endl -done -v +

#@gmic scandoc : _smooth,_background,_black,_white
#@gmic : improve scanned document
#@gmic : image.jpg -scandoc
scandoc: -skip ${1=3},${2=100},${3=10%},${4=90%}
-v - -repeat @# -l[$>] -split_opacity -l[0]
-median $1 --blur $2 -- -min 0
-s c -n 0,1 -a c -c $3,$4 -n 0,255
-endl -a c -endl -done -v +

#@gmic oblur: _nb_scales,_nb_angles
#@gmic : Oriented blurs
oblur: -skip ${1=1},${2=6}
-v - -repeat @# -l[$>]
  -repeat $1 s={2^($>+2)} -repeat $2 a={$>/@#*180}
  -echo_stdout $s", "$a
  #--blur_linear[0] $s,.1,$a
  --l[0] -blur_linear $s,1,$a  --blur 1 -- -endl
  -if {@#==3}  -max[1,2] -endif
  -done -done
  -rm[0]
-endl -done -v +

#@gmic oheat: _nb_scales,_nb_angles
#@gmic : Oriented blurs
oheat: -skip ${1=1},${2=6}
-v - -repeat @# -l[$>]
  -repeat $1  -repeat $2 a={$>/@#*180}
    --l[0] -blur_linear 2,.5,$a  --blur 1 -- -endl
    -done
    -max[1--1] -+
    -done
-endl -done -v +

#@gmic warp_affine
#@gmic : Warp the image [0] using an affine field defined by a 3x3 matrix [1]
#@gmic : $ image.jpg 3 -f[-1] 1 -diagonal[-1] -noise[-1] .1  --warp_affine -k[0,-1]
warp_affine :
--l[0,1]
 params=(@{1,i(0,0)},@{1,i(1,0)},@{1,i(2,0)};\
         @{1,i(0,1)},@{1,i(1,1)},@{1,i(2,1)};\
         @{1,i(0,2)},@{1,i(1,2)},@{1,i(2,2)})
 @{0,w},@{0,h},1,1,1 --f[-1] x --f[-1] y -a[-3--1] c
 -mix_channels[-1] $params
 -channels[-1] 1,2
 -warp[0] [-1],0,1,0 -rm[-1,-2]
-endl
-rm[0,1]

#@gmic midway
#@gmic : Midway equalization of two channels
#@gmic : $ image.jpg -channels 0,1 -s c -*[-1] 2 -a c --midway
midway :
-repeat @# -l[$>]
--l[0]
  -resize 20%,20%
  -s c -unroll y -l[0] 1,@{0,h},1,1,1 -a x -endl  -transpose[0]
  -l[0] -svd -f[-2] 'if(i>1e-6,1/i,0)' -diagonal[-2] -transpose[-1] -mmul -endl -mmul
  a=@{0,0} b=@{0,1} -rm[-1]
-endl
-s c
-+[-1] {$b} -*[-1] {1/$a} -a c
-endl -done

#@gmic vobs : _scale
#@gmic : Motion quantity (Normal motion)  h * (|Ixy|^2 |It|/|Ixy|) / h * Ixy^2
#@gmic : $ 100,100,10 -noise 1 -blur 1 --vobs
vobs : -check "${1=1}>0 && ${2=3}>0"
-e[^-1] "Motion quantity with scale $1"
-v - -repeat @# -l[$>]
-gradient -a[0,1] c -norm[0] -abs[1] -*[1] [0] -sqr[0] -blur $1,1,1 -reverse -max[1] 5% -/
-endl -done -v +

#@gmic display_vobs :
#@gmic : Display local diffusion coefficient
#@gmic : $ 200,100 -noise .7,2 -blur 2,1,1 -repeat 20 --l[-1] --laplacian -*[-1] .05 -+ -endl -done  -a z -display_vobs
display_vobs :
--vobs 1 A={round(@{-1,im},0.001)} B={round(@{-1,iM},0.001)} -*[-1] '{128/max(im,iM)}' -+[-1] 128  -map[-1] 5
-resize[0] 100%,100%,100%,3,1 -apply_gamma[0] 1.5 -n[0] 0,255
-l[0] -s z -frame 5,12,64 -shift 0,5,0,0,2 -text "Original sequence",5,0,13,1,255 -a z -endl
-l[1] -s z -repeat @# -l[$>] 1,100% -f[-1] 'h-y' -n 0,255  -map[-1] 5 -resize[-1] 5,@{0,h},1,3,5 -frame[-1] 3,0,64  -resize[-1] 100%,@{0,h},1,3,5 -a x
-frame 5,12,64 -shift 0,5,0,0,2
-text "Vobs ["$A":"$B"]",5,0,13,1,255 -endl -done -a z -endl
-a x

display_pseudocolor :
 A={round(@{-1,im},0.0001)} B={round(@{-1,iM},0.0001)} -n[-1] 0,255 -map[-1] 5
 -rectangle {w-50-5},{h/4-5},{w-5},{h-h/4+5},.5,0,0,0
 -add_colorbar[-1] {w-50},{h/4},{w-40},{h-h/4},$A,$B,6,255

#@gmic display_colordepth : _dz
display_colordepth :
-e[^-1] "display the 3D image with a depth color coded."
-v - -repeat @# -l[$>]
 H={d*$1} -colordepth , -a z -min {ia+10*sqrt(iv)} -n 0,255 -s z
 -rectangle {w-50-5},{h/4-5},{w-5},{h-h/4+5},.5,0,0,0
 -add_colorbar[-1] {w-50},{h/4},{w-40},{h-h/4},0,$H,6,255
-endl -done -v +

#@gmic add_colorbar : x0,y0,x1,y1,_min,_max,_ntics,color,colormap
#@gmic : Add a colorbar to the image
#@gmic : $ gmic image.jpg -luminance -map 5 -add_colorbar {w-40},20,{w-30},{h-20},0,255,6,255,5
add_colorbar :
-skip ${5=0},${6=255},${7=6},${8=255},${9=""},${10=5}
-repeat @# -l[$>]
{$3-$1},{$4-$2} -l[-1] -f 'h-y' -n 0,255 -map $10 -endl
-frame[1] 1,1,$8 -image[0] [1],$1,$2,0,0,1 -k[0]
-repeat $7
  val={round($5+$>/($7-1)*($6-$5),.001)}
  -text "- "$val" "$9,{$3+1},{$4-$>*($4-$2-5)/($7-1)-10},13,1,$8
-done
-endl -done

#@gmic local_diffusion_coefficient : _scale,_threshold
#@gmic : Estimate local diffusion coefficient It - D (Ixx+Iyy)=0 using D=It/(Ixx+Iyy)
#@gmic : $ 100,100 -noise .7,2 -blur 2,1,1 -repeat 20 --l[-1] --laplacian -*[-1] .05 -+ -endl -done  -a z -local_diffusion_coefficient 2,.5
local_diffusion_coefficient : -check "${1=2}>0 && ${2=.5}>=0"
-e[^-1] "Local diffusion coefficient estimation using scale $1 and threshold $2"
-v - -repeat @# -l[$>]
   --l[0] -s z -laplacian -a z -endl           # Ixx+Iyy
   --l[0] -s z -gradient_norm -a z -sqr -endl  # ||Ix+Iy||^2
   -gradient[0] z,1                            # It
   -l[0,1] # try to compute It/Ixx+Iyy as stably as possible
     R={@{1,ia}+$2*sqrt(@{1,v})}
     -a c -f 'b=i(x,y,z,0);a=i(x,y,z,1);if(abs(a)>abs(b),b/a,if(abs(b)>$R,1/(b/a),0))'
     -channels 0
   -endl
   -*[0] [1] -blur $1,1,1 -max[1] {@{1,ia}+$2*sqrt(@{1,v})}  -/
   -channels 0
-v + -endl -done

ldc :
-local_diffusion_coefficient $*

#@gmic display_ldc :
#@gmic : Display local diffusion coefficient
#@gmic : $ 200,100 -noise .7,2 -blur 2,1,1 -repeat 20 --l[-1] --laplacian -*[-1] .05 -+ -endl -done  -a z -display_ldc
display_ldc :
--ldc 5,3 A={round(@{-1,im},0.001)} B={round(@{-1,iM},0.001)} -*[-1] '{128/max(im,iM)}' -+[-1] 128  -map[-1] 5
-resize[0] 100%,100%,100%,3,1 -apply_gamma[0] 1.5 -n[0] 0,255
-l[0] -s z -frame 5,12,64 -shift 0,5,0,0,2 -text "Original sequence",5,0,13,1,255 -a z -endl
-l[1] -s z -repeat @# -l[$>] 1,100% -f[-1] 'h-y' -n 0,255  -map[-1] 5 -resize[-1] 5,@{0,h},1,3,5 -frame[-1] 3,0,64  -resize[-1] 100%,@{0,h},1,3,5 -a x
-frame 5,12,64 -shift 0,5,0,0,2
-text "Local diffusion coefficient ["$A":"$B"]",5,0,13,1,255 -endl -done -a z -endl
-a x

#@gmic print_psnr : _max_value
#@gmic : Display the psnr on the image list taking the first one as a reference
#@gmic : $ image.jpg --noise 20 --blur[-1] 1 -print_psnr
print_psnr : -skip ${1=255}
-e[^-1] "Compute PSNR with image 0 and print it on the other images."
-v - --psnr $1
-repeat {@#-2} -text_outline[{$>+1}] "PSNR:"{round(@{-1,i(0,$>+1)},.01)}"dB",5,5,30,1 -done
-rm[-1] -v +

#@gmic noise_std
#@gmic : Estimate the noise variance
#@gmic : $ image.jpg -noise 10 sigma={round(@{-noise_std},.1)} -text_outline "Noise std:"$sigma,5,5,30,1
noise_std :
-e[^-1] "Compute noise variance."
-v - --laplacian -if {@{0,d}==1}  -u {@{-mad[-1]}/sqrt(20.0)} -else -u {@{-mad[-1]}/sqrt(42.0)} -endif -rm[-1]
-v +

#@gmic denoise_patch_dict : _patch_size,_nb_of_shifts,_thres_comp,_thres_coef
#@gmic : Denoising using a dictionnary of patches learn on the image
#@gmic : work in progress...
#@gmic : $ image.jpg --noise 20 --denoise_patch_dict[1] , -print_psnr
denoise_patch_dict: -skip ${1=8},${2=8},${3=1.1},${4=1.1}
-e[^-1] "Denoising using a dictionnary of "$1"x"$1" patches with "$2" shifts, threshold $3x(noise std) for components and $4x(std) for coefficients."
-v - -repeat @# -l[$>]
  Sigma=@{-noise_std[0]} # measure the noise level
  # mirror to prevent side effect
  --crop 0,0,$1,100% -mirror[-1] x -reverse --crop[-1] {w-$1-1},0,100%,100% -mirror[-1] x -a x
  --crop 0,0,100%,$1 -mirror[-1] y -reverse --crop[-1] 0,{h-$1-1},100%,100% -mirror[-1] y -a y
  # resize the image to get integer nb of tiles (using mirrored version)
  oW=@{0,w} oH=@{0,h} oS=@{0,s} nW={$1*round($oW/$1,1,1)} nH={$1*round($oH/$1,1,1)}
  --crop {2*$oW-$nW},0,100%,100% -mirror[-1] x -a x
  --crop 0,{2*$oH-$nH},100%,100% -mirror[-1] y -a y
  NtileX={round($nW/$1)}  NtileY={round($nH/$1)}
  # compute a dictionnary (use several shifts)
  --l[-1]
    -repeat $2
      -if {$2>1} dx={round(?(0,$1))} dy={round(?(0,$1))} -else dx=0 dy=0 -endif
      --shift[0] $dx,$dy,0,0,2
      -split_tiles[-1] $NtileX,$NtileY pW=@{1,w} pH=@{1,h} # split the image
    -done -rm[0]
    -unroll y -a x n=@{-1,w} -- 'ia' --transpose[-1] -**[-2,-1] -/ $n -eigen # PCA
    # select components based on noise level
    -l[-2] -unroll x -sqrt -gt {$3*$Sigma} -f 'abs(i(x+1)-i(x))'
    T=@{-1,C} 4 -f[-1] $T T=@{-1,i(0)} -endl
    -if {$T==0} T=100% -endif -k[-1] -columns 0,$T
  -endl
  # denoise the image using the dictionnary
  -repeat $2
    -if {$2>1} dx={round(?(0,$1))} dy={round(?(0,$1))} -else dx=0 dy=0 -endif
    --shift[0] $dx,$dy,0,0,2
    -l[1,-1]
      -l[1] -split_tiles $NtileX,$NtileY -unroll y -a x -endl
      -transpose[0] --**                # project on the dictionnary
      t=@{-mad[-1]}                     # estimate variance of coefficients
      -f[-1] 'if(abs(i)<$4*$t,0,i)'     # threshold the coefficients
      -rm[1] -transpose[0] --** -rm[-2] # project back
    -endl
    -l[-1]
       -s x -resize $pW,$pH,1,$oS,-1
       -append_tiles $NtileX,$NtileY
       -shift {-$dx},{-$dy},0,0,2
     -endl
  -done
  -rm[0,1]
  -+ -/ $2
  -crop {$1+1},{$1+1},{$oW-$1-2},{$oH-$1-2}
-endl -done -v +


#@gmic iuwt: _levels,_scale
#@gmic : compute a pseudo "isotropic undecimated wavelet transform"
#@gmic : related to the laplacian pyramid of Burt and Adelson
#@gmic : you can compute the inverse using a sum of all coefficients
#@gmic : $ image.jpg -wavelet 4,1 -n 0,255 -append_tiles
#@gmic : $ image.jpg -wavelet 3,1 -+
iuwt: -skip ${1=3},${2=1} -check $1>1
  -v - -repeat @# -l[$>]  scale=$2
   -repeat {$1-1} scale={2*$scale}
     -l[-1] --blur $scale --- -reverse[-1,-2] -rm[0] -endl
    -done
  -endl -done -v +

#@gmic denoise_iuwt:_levels,_scale,_threshold
#@gmic : denosing based on a pseudo "isotropic undecimated wavelet transform"
#@gmic : $ image.jpg --noise 10 --denoise_iuwt[-1] , -print_psnr
denoise_iuwt: -skip ${1=3},${2=.75},${3=3}
  -v - -repeat @# -l[$>]
    -iuwt $1,$2 sigma=@{-mad[0]} -threshold[0--2] {$3*$sigma},1 -+
  -endl -done  -v +

denoise_iuwt2: -skip ${1=3},${2=.75},${3=3}
  -v - -repeat @# -l[$>]
    -iuwt $1,$2
    -repeat {@#-1} -l[$>]
    sigma=@{-mad[0]}
    -threshold {$3*$sigma},1
    #-f[0--2] 'if(abs(i)<$3*$sigma,0,i)'
    -endl -done
    -d -+
  -endl -done  -v +


#---------------------------------
#
#@gmic :: Segmentation
#
#---------------------------------

#@gmic contour2d: _tolerance
#@gmic : Draw a 2D contour of regions with tolerance _tolerance
#@gmic : Default value _tolerance=.1
#@gmic : $ image.jpg -norm -blur 1 -gt 50% --contour2d
contour2d: -skip ${1=.1}
-v - -repeat @# -l[$>]
-f 'if(abs(i(x,y)-i(x+1,y+1))>$1||abs(i(x,y)-i(x+1,y))>$1,1,0)'
-endl -done -v +

#@gmic segment_snake : _nb_iter,_time_step,_smoothness,_threshold
#@gmic : Segment an image using an adaptation of Chan and Vese's method.
#@gmic : Default values _nb_iter=10,_time_step=1,_smoothness=100,_threshold=50%
#@gmic : Reference Chan and L. Vese,Active contours without edges, IEEE transactions on image processing 10(2) (2001), pp. 266-277
#@gmic : $ 256,128 -text "GMIC",40,10,100,1,255 -blur 1 -noise 20 --segment_snake , -contour2d[-1] , -resize[-1] 100%,100%,1,3,0 -n 0,255 -blend add
segment_snake: -skip ${1=10},${2=1},${3=100},${4=50%},${5=1}
-e[^-1] "Segment the image using active contours without edges using $1 iterations and time step $2, smoothness $3 and initialize with threshold of $4."
-v - -repeat @# -l[$>]
  -luminance
  --blur $5 -gt[-1] $4                                              # initialization
  -l[-1] --distance 0 -negative[0] -distance[0] 0 -*[0] -1 -+ -endl # levelset
  -repeat $1
    # compute mean and variance of the two regions (original version is with mean only)
    # the molified step function is given by a blur of the sharp step function
    --lt[-1] 0 -blur[-1] $5 --*[0,-1] swx=@{-1,ia} sw=@{-2,ia} M1={$swx/$sw}
    -sqr[-1] swx2=@{-1,ia}  S1={max(1e-3,$swx2/$sw^2-$M1^2)} -rm[-1,-2]
    --gt[-1] 0 -blur[-1] $5 --*[0,-1] swx=@{-1,ia} sw=@{-2,ia} M2={$swx/$sw}
    -sqr[-1] swx2=@{-1,ia}  S2={max(1e-3,$swx2/$sw^2-$M2^2)} -rm[-1,-2]
    --iee[-1]                                                     # regularization
    --f[0] '(1.0/$3)*(((i(x,y)-$M1)^2)/$S1-((i(x,y)-$M2)^2)/$S2)' # data term
    -+[-2,-1]
    -*[-1] {$2/(0.0001+max(abs(@{-1,m}),abs(@{-1,M})))}           # adaptive time step
    -+[-2,-1]
  -done
#  -echo_stdout "("$M1","{sqrt($S1)}");("$M2", "{sqrt($S2)}")"
  -blur[-1] $5 -gt[-1] 0 -rm[0]
-endl -done -v +

# segment_cells:
#@gmic : Cell segmentation using watershed
#@gmic : $ 256,256 -noise .05,2 -blur 10,1,1 -min 80% -noise 5% --segment_cells 2,10% -contour2d[-1] , -resize[-1] 100%,100%,1,3,0 -n 0,255 -blend add
segment_cells: -skip ${1=5},${2=10%}
-blur $1
--l[0]
 --max_patch , -gt[0] $2 -* --distance 1 -mul[-1] -1 -label[-2] 0
 -watershed[-2] [-1] -rm[1]
-endl
-gt[0] $2
-*

#---------------------------------
#
#@gmic :: Patterns
#
#---------------------------------

#@gmic periodic_dots : _nb_angles,_scale,_start_angle
#@gmic : Generate a peridic dot pattern with 'nb angles', 'scale' and 'start angle'.
#@gmic : Default values 'nb angle=6', 'scale=4' and 'start_angle=0'
#@gmic : $ 64,64 -periodic_dots 3,6,.1 -repeat 34 -i [0]  -done   -append_tiles
periodic_dots : -skip ${1=6},${2=4},${3=.5}
-e[^-1] "Generate a periodic dot pattern with "$1" angles, scale "$2", and orientation "$3"."
-v - -repeat @# -l[$>]
 -s c -repeat @# -l[$>]
 --resize {max(w,h)},{max(w,h)},100%,100%,0
 -l[-1]
 -f 0
 -repeat $1
   -circle {w*(.5+.5/$2*cos(2*pi*($>+$3/180*pi)/$1))},{w*(.5+.5/$2*sin(2*pi*($>+$3/180*pi)/$1))},0,1,255
 -done
 -fft -a c -norm -fftshift -n 0,255
 -endl
 -resize[-1] [0],0
 -k[-1]
 -endl -done -a c
-endl -done -v +

#@gmic rays :
#@gmic : generate rays patterns
rays :
-e[^-1] "Generate a ray pattern centered in ($1,$2)"
-f 't=atan2(y-$2,x-$1);sin($3*t+$4)'

#@gmic fractional_brownian_motion : 0<=_hurst_index<=1,_epsilon>0
#@gmic : Generate fractional brownian motion nd signal
#@gmic : Using a power low of the form (eps+|f|)^(-2^H-1)
#@gmic : where f is the module of the frequency, H the husrt index and eps _epsilon.
#@gmic : (see also -clouds)
#@gmic : $ 400,300 -frational_brownian_motion
fractional_brownian_motion : -skip ${1=.5},${2=1} -check "$1>=0&&$1<=1" -check "$2>0"
-v - -repeat @# -l[$>]
-f 0 -noise 1
-fft -fftshift
-f 'rx=x-w/2;ry=y-h/2;i*($2+sqrt(rx*rx+ry*ry))^(-2*$1-1)'
-fftshift -ifft
-k[0]
-endl -done -v +

#@gmic clouds : _density_of_blue_sky>0,_amplitude,0<=_hurst_index<=1,_epsilon>0
#@gmic : Generate clouds on the image (see also 'frational_brownian_motion')
#@gmic : $ 64,64 -repeat 3 --clouds {10+20*$>}% -done -rm[0]
clouds : -skip ${1=50%},${2=1},${3=.5},${4=1}
-v - -repeat @# -l[$>]
-channels 0
-fractional_brownian_motion $3,$4 -negative -min $1 -negative -resize 100%,100%,1,4
-n 0,255 -s c -n[0-2] 190,255  -n[3] 0,255 -a c
-endl -done -v +

#@gmic clearbluesky:
#@gmic : Generate a Clear Blue Sky
#@gmic : $ 400,300,1,3 -clearbluesky --clouds 50% -blend alpha
clearbluesky :
-v - -repeat @# -l[$>]
1,2,1,3 -f[-1] '63,70,120,144,190,215' -resize[-1] [0],5 -k[-1]
-endl -done -v +

#---------------------------------
#
#@gmic ::  GIMP
#
#---------------------------------
#@gimp _<b>Details</b>

#@gimp Sharpen [Whiten] : jeje_whiten_frequency, jeje_whiten_frequency_preview
#@gimp : Alpha = float(50,0,100)
#@gimp : Cut = bool(false)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical")
#@gimp : sep = separator(), note = note(<b>Note:</b>This filter equalizes frequencies in the image.)
#@gimp : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>.      Latest update: <i>2013/06/01</i>.</small>")
jeje_whiten_frequency :
  -whiten_frequency {exp($1/100)-1}
  -if $2 -c 0,255 -n 0,255 -else -n 0,255 -endif

jeje_whiten_frequency_preview :
  -gimp_split_preview "-jeje_whiten_frequency $1,$2",$-1

#@gimp Wavelet Decompose : jeje_wavelet_decompose,jeje_wavelet_decompose_preview
#@gimp : Levels = int(4,2,8)
#@gimp : Scale = float(.75,1,3)
#@gimp : Action  = choice("Decompose","Recompose")
#@gimp : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/12/12</i>.</small>")
jeje_wavelet_decompose:
  -if {$3==0}
  -iuwt $1,$2 -l[0--2] -* 2 -+ 128 -endl
  -reverse -a x -c 0,255
  -else
  -s x,$1 -l[0--2] -- 128 -* 0.5 -endl -+ -c 0,255
  -endif

jeje_wavelet_decompose_preview:
  -jeje_wavelet_decompose $1,$2,$3


#@gimp Wavelet Equalizer : jeje_wavelet_equalizer,jeje_wavelet_equalizer_preview
#@gimp : Level 1 = float(15,0,20)
#@gimp : Level 2 = float(7,0,20)
#@gimp : Level 3 = float(5,0,20)
#@gimp : Level 4 = float(0,0,20)
#@gimp : Remix   = float(50,0,100)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical")
#@gimp : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/12/12</i>.</small>")
jeje_wavelet_equalizer:
--l
-iuwt 5,.75
-threshold[0] $1,1 -threshold[1] $2,1
-threshold[2] $3,1 -threshold[3] $4,1
-+
-endl
-*[1] $5 -*[0] {100-$5} -+ -/ 100
-c 0,255

jeje_wavelet_equalizer_preview:
-gimp_split_preview "-jeje_wavelet_equalizer $1,$2,$3,$4,$5",$-1

#@gimp _<b>Repair</b>
#@gimp Denoise [Block PCA]: jeje_denoise_patch_dict, jeje_denoise_patch_dict_preview
#@gimp : Patch = choice(1,4,8,16,32)
#@gimp : Cycles = int(8,1,32)
#@gimp : Components = float(1.1,1,9)
#@gimp : Coefficients = float(1.1,0,9)
#@gimp : Remix = float(0,0,1)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical")
#@gimp : sep = separator(), note = note(<b>Note:</b>This filter is quite time consuming.)
#@gimp : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>.      Latest update: <i>2013/03/29</i>.</small>")
jeje_denoise_patch_dict:
  --denoise_patch_dict {2^($1+2)},$2,$3,$4
  -*[0] $5 -*[1] {1-$5} -+ -c 0,255

jeje_denoise_patch_dict_preview:
  -gimp_split_preview "-jeje_denoise_patch_dict $*",$-1

#@gimp Local Wiener : jeje_localwiener, jeje_localwiener_preview
#@gimp : Scale = float(2,.5,10)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical")
#@gimp : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/06/07</i>.</small>")
jeje_localwiener :
-localwiener $1 -c 0,255

jeje_localwiener_preview:
-gimp_split_preview "-jeje_localwiener $1",$-1

#@gimp Denoise IUWT : jeje_denoise_iuwt,jeje_denoise_iuwt_preview
#@gimp : Number of scales = int(3,2,6)
#@gimp : Scale = float(1,.1,3)
#@gimp : Threshold = float(3,0,10)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical")
#@gimp : sep = separator(), note = note("<small><b>Note:</b> Compute a pseudo wavelet transform by applying successivly 'Number of scales' times a blur of parameter 'Scale' and thresholding the successives differences by a soft-threshold equal to 'Threshold' times the estimated noise standard deviation from the first wavelet level.'</small>")
#@gimp : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/12/12</i>.</small>")
jeje_denoise_iuwt :
-denoise_iuwt $1,$2,$3

jeje_denoise_iuwt_preview:
-gimp_split_preview "-jeje_denoise_iuwt $1,$2,$3",$-1

#@gimp Unstrip : jeje_unstrip, jeje_unstrip_preview
#@gimp : Smoothness = float(1,0,10)
#@gimp : Size = float(20,1,50)
#@gimp : Sensitivity = float(4,1,10)
#@gimp : Normalize = bool(true)
#@gimp : FFT preview = bool(false)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical")
#@gimp : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/06/10</i>.</small>")
jeje_unstrip :
  -unstrip $1,$2,$3
  -if $5 -tape -powerspectrum -else
  -if -$4 -n 0,255 -else -c 0,255 -endif
  -endif

jeje_unstrip_preview :
  -gimp_split_preview "-jeje_unstrip $1,$2,$3,$4,$5",$-1

#@gimp Repair scanned document: jeje_scandoc, jeje_scandoc_preview(0)
#@gimp : note = note(Use filter is useful to post process document you scan with a digital camera. It peforms smoothing, background correction and white balance adjustement)
#@gimp : Smoothness = int(3,1,7)
#@gimp : Background = float(1,10,100)
#@gimp : White level = float(90,0,100)
#@gimp : Black level = float(5,0,100)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical")
#@gimp : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/11/03</i>.</small>")
jeje_scandoc :
  -scandoc $1,$2%,$3%,$4%

jeje_scandoc_preview :
  -gimp_split_preview "-jeje_scandoc $1,$2,$3,$4",$-1

#@gimp _<b>Patterns</b>
#@gimp Periodic dots: jeje_periodic_dots, jeje_periodic_dots_preview
#@gimp : Number = int(6,2,32)
#@gimp : Scale = float(4,1,12)
#@gimp : Angle = float(0,0,360)
#@gimp : Repeat = int(1,1,10)
#@gimp : Map = choice(None,default,HSV,lines,hot,cool,jet,flag,cube)
#@gimp : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/05/29</i>.</small>")
jeje_periodic_dots:
  tW={max(w,h)/$4}
  $tW,$tW
  -periodic_dots[-1] $*
  -repeat {$4*$4-1}
   -i [-1]
  -done
  -append_tiles[1--1] $4,$4 -k[-1]
  -if {$5>0} -n 0,255 -map {$5-1} -endif

jeje_periodic_dots_preview:
  -jeje_periodic_dots $*

#@gimp Clouds : jeje_clouds, jeje_clouds_preview
#@gimp : Density = float(50,0,100)
#@gimp : Smoothness = float(.5,0,1)
#@gimp : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/05/29</i>.</small>")
jeje_clouds :
 --clouds $1%,1,$2 -blend alpha

jeje_clouds_preview :
 -jeje_clouds $1,$2

#@gimp Strip : jeje_strip, jeje_strip_preview
#@gimp : Angle = float(45,0,90)
#@gimp : Frequency = float(50,0,100)
#@gimp : Phase =  float(0,0,180)
#@gimp : Amplitude = float(1,0,2)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical")
#@gimp : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/06/07</i>.</small>")
jeje_strip :
  theta={pi*$1/180}
  -f '0.5*i*(1+$4*sin(2*pi*$2*(cos($theta)*x/w+sin($theta)*y/h)+2*pi*$3/180))'
  -c 0,255

jeje_strip_preview :
  -gimp_split_preview "-jeje_strip $*",$-1

#@gimp Rays : jeje_rays, jeje_rays_preview
#@gimp : X center = float(50,0,100)
#@gimp : Y center = float(50,0,100)
#@gimp : Frequency = float(10,0,100)
#@gimp : Angle = float(0,0,360)
#@gimp : Proportion = float(0.5,0,1)
#@gimp : Color 1 = color(255,0,0)
#@gimp : Color 2 = color(255,255,0)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical")
#@gimp : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/10/29</i>.</small>")
jeje_rays :
-s c
-l[0] -rays {w*$1/100},{h*$2/100},$3,$4 -n 0,1 -gt $5 -n $6,$9 -endl
-l[1] -rays {w*$1/100},{h*$2/100},$3,$4 -n 0,1 -gt $5 -n $7,$10 -endl
-l[2] -rays {w*$1/100},{h*$2/100},$3,$4 -n 0,1 -gt $5 -n $8,$11 -endl
-a c

jeje_rays_preview:
-gimp_split_preview "-jeje_rays $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11",$-1

#@gimp _<b>Degradations</b>
#@gimp Tilt Shift : jeje_tilt_shift, jeje_tilt_shift_preview
#@gimp : Tilt = float(10,0,90)
#@gimp : Shift = float(-10,-50,50)
#@gimp : Size = float(75,1,100)
#@gimp : Amount = int(3,2,30)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical")
#@gimp : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/06/07</i>.</small>")
jeje_tilt_shift:
#--gradient_norm -blur[-1] $3% -reverse -repeat $1 --blur[-1] {$2/$1}  -done
#-a[1--1] z
#-l[0] -tones $1 -blur   $3% -reverse  -a z -resize 100%,100%,100%,3 -endl
#-d -*  -s z -+ -n 0,255
theta={pi*(90-$1)/180}
scale={3*$3/min(w,h)*100}
100%,100%
-f[-1] '(1-exp(-.5*(cos($theta)*(x-w/2)+sin($theta)*(y-h/2)+$2*max(w,h)/100)^2/($scale*$scale)))'
-reverse -repeat $4 --blur[-1] 1  -done  -a[1--1] z
-l[0] -tones {$4+1} -blur 1 -a z  -endl
-reverse -*  -s z -+

jeje_tilt_shift_preview:
-gimp_split_preview "-jeje_tilt_shift $1,$2,$3,$4",$-1

#@gimp _<b>Details</b>
#@gimp Local variance normalization : jeje_normalize_local_variance, jeje_normalize_local_variance_preview
#@gimp : Amplitude = float(50,0,100)
#@gimp : Smoothness = float(5,0,20)
#@gimp : Threshold = float(5,0,100)
#@gimp : Repeat = int (1,1,4)
#@gimp : Channel(s) = choice(3,"All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Alpha","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical")
#@gimp : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/10/30</i>.</small>")
jeje_normalize_local_variance :
  -apply_channels "-normalize_local_variance $1,$2,$3,$4",$5,0
  -c 0,255

jeje_normalize_local_variance_preview:
  -gimp_split_preview "-jeje_normalize_local_variance $1,$2,$3,$4,$5",$-1

#@gimp _<b>Testing</b>
#@gimp <i>J&#233;J&#233;</i>
#@gimp 3D Rendering: jeje_render3d, jeje_render3d_preview
#@gimp : Input image = file()
#@gimp : Size = int(8,4,16)
#@gimp : Quality = int(6,2,16)
#@gimp : Opacity = float(0.1,0,1)
#@gimp : Angle X = float(240,0,360)
#@gimp : Angle Y = float(0,0,360)
#@gimp : Angle Z = float(30,0,360)
#@gimp : Zoom = float(1,0,3)
#@gimp : Top color = color(32,32,64,255)
#@gimp : Bottom Color = color(64,128,96,255)
#@gimp : Render = bool(false)
#@gimp : sep = separator(), note = note(<b>Note:</b>Adjust the 3D view first and then enable render to compute the volume rendering.)
#@gimp : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/05/29</i>.</small>")
jeje_render3d:
  W=@{0,w}
  1,2,1,4 -f[-1] $9,$13,$10,$14,$11,$15,$12,$16 -resize[-1] @{0,w},@{0,h},1,4,5
  -blend alpha
  -i $1 -a[1--1] z
  -l[-1]
  -if $17 -displayvolume $2,$3,$4 -else  -boundingbox3d 20 -endif
  -rotate3d 0,0,1,$7
  -rotate3d 0,1,0,$6
  -rotate3d 1,0,0,$5
  -c3d -n3d -*3d {3*$W*$8/4}
  -endl
  -object3d[0] [1],50%,50%,0,1
  -n 0,255
  -rm[1]

jeje_render3d_preview:
    -jeje_render3d $*



# Local Variables:
# mode: sh
# End:
#
# (End of G'MIC custom commands)
